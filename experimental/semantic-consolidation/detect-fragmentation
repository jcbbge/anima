#!/usr/bin/env node

/**
 * SEMANTIC FRAGMENTATION DETECTION
 * 
 * Scans existing memories for Ï† fragmentation across semantic clusters.
 * Provides recommendations for manual consolidation.
 */

import { detectPhiFragmentation } from '../src/services/semanticConsolidationService.js';

async function main() {
  console.log('\nðŸ” Scanning for Ï† fragmentation...\n');
  
  const fragments = await detectPhiFragmentation(0.92);
  
  if (fragments.length === 0) {
    console.log('âœ… No significant Ï† fragmentation detected.\n');
    return;
  }
  
  console.log(`âš ï¸  Found ${fragments.length} potential fragmentation clusters:\n`);
  
  // Group by recommendation level
  const highConfidence = fragments.filter(f => f.consolidation_recommendation === 'HIGH_CONFIDENCE_MERGE');
  const potential = fragments.filter(f => f.consolidation_recommendation === 'POTENTIAL_MERGE');
  const related = fragments.filter(f => f.consolidation_recommendation === 'RELATED');
  
  if (highConfidence.length > 0) {
    console.log(`\nðŸ”´ HIGH CONFIDENCE MERGES (${highConfidence.length}):`);
    console.log('   These should almost certainly be consolidated.\n');
    
    highConfidence.slice(0, 10).forEach((frag, idx) => {
      console.log(`   ${idx + 1}. Similarity: ${(frag.similarity * 100).toFixed(2)}%`);
      console.log(`      Total Ï†: ${frag.total_phi.toFixed(2)} (currently fragmented: ${frag.phi_a.toFixed(2)} + ${frag.phi_b.toFixed(2)})`);
      console.log(`      Memory A: "${frag.content_a.substring(0, 60)}..."`);
      console.log(`      Memory B: "${frag.content_b.substring(0, 60)}..."`);
      console.log(`      IDs: ${frag.id_a} â†” ${frag.id_b}\n`);
    });
  }
  
  if (potential.length > 0) {
    console.log(`\nðŸŸ¡ POTENTIAL MERGES (${potential.length}):`);
    console.log('   These may benefit from consolidation (manual review recommended).\n');
    
    potential.slice(0, 5).forEach((frag, idx) => {
      console.log(`   ${idx + 1}. Similarity: ${(frag.similarity * 100).toFixed(2)}%`);
      console.log(`      Total Ï†: ${frag.total_phi.toFixed(2)}`);
      console.log(`      Content: "${frag.content_a.substring(0, 50)}..." â†” "${frag.content_b.substring(0, 50)}..."\n`);
    });
  }
  
  // Calculate total potential Ï† consolidation
  const totalFragmentedPhi = fragments.reduce((sum, f) => sum + parseFloat(f.total_phi), 0);
  const avgFragmentation = fragments.reduce((sum, f) => sum + parseFloat(f.similarity), 0) / fragments.length;
  
  console.log(`\nðŸ“Š FRAGMENTATION SUMMARY:`);
  console.log(`   Total clusters: ${fragments.length}`);
  console.log(`   Total fragmented Ï†: ${totalFragmentedPhi.toFixed(2)}`);
  console.log(`   Average similarity: ${(avgFragmentation * 100).toFixed(2)}%`);
  console.log(`\n   ðŸ’¡ Semantic consolidation is now active for NEW memories.`);
  console.log(`   ðŸ’¡ Existing fragmentation will persist unless manually consolidated.\n`);
  
  if (highConfidence.length > 0) {
    console.log(`\nâš¡ RECOMMENDATION:`);
    console.log(`   Consider manual consolidation of ${highConfidence.length} high-confidence pairs.`);
    console.log(`   This could consolidate ${highConfidence.reduce((s, f) => s + parseFloat(f.total_phi), 0).toFixed(2)} Ï† into stronger semantic attractors.\n`);
  }
}

main().catch(console.error).finally(() => process.exit());
